Поскольку в этом варианте игроки бросают гораздо больше костей, чем в обычном, им важно знать модификаторы бросков для этих новых бросков. Поэтому было бы полезно иметь инструмент для игроков, позволяющий им в любой момент посмотреть все модификаторы бросков\ (как макро-действие, доступное всем игрокам\). Аналогично, вы захотите, чтобы инструмент рассказывал вам, какие "показатели" у различных НИП/монстров, которые противостоят этим броскам, чтобы вычислить простое число, которое игроку нужно побить.

То есть, вам нужно что-то, что выдавало бы примерно следующее:

КЗ для Боба: +4 = 14\(Вычтите потерянный бонус за уклонение\).

Некоторые из этих значений содержат "состояния". Например, при КЗ на плоских ногах вы теряете бонус Лов.\(если он у вас был.\), но сохраняете штраф Лов.\. Вам нужно будет представить эти состояния в вашем инструменте, но единственным доступным инструментом обычно являются макросы/способности, если только вы не можете позволить себе уровень Pro\(для пользовательских листов персонажа\). На самом деле, вы не можете сделать условную математику, подобную следующей, потому что в макросах/способностях нет "условного" синтаксиса.

```text
[[ @{selected|dexmod} < 1 ? @{selected|dexmod} : 0 ]]
```
Это значит, что вам придется использовать представление костей, чтобы отобразить все эти модификаторы и все их врожденные состояния, и отображать их через шепот ГМа, чтобы никто, кроме вас и ГМа, не мог видеть эту информацию.

```text
/w gm Flat-Footed AC for @{selected|character_name}: +[[ @{selected|modifier} ]] = [[ @{selected|modifier} +10 ]] (Subtract lost Dodge bonus)
```


Следующие формулы позволяют создавать очень простые состояния, основанные на неравенствах, используя только представление Кости. Предположим, что в формулах все переменные ALL\_CAPS являются целыми числами, которые вы планируете заменить на реальные целые числа \(или атрибуты, которые являются целыми числами\), когда будете их реализовывать. \(Примечание: Если вы заменяете переменную явным отрицательным числом, порядок операций Roll20 должен содержать это отрицательное число в круглых скобках.\) Больше, чем или равно

Формула ниже возвращает 1 для всех целых чисел MINIMUM\_VALID\_NUMBER или больше, и возвращает 0 для всех остальных целых чисел.

```text
[[ ( 1 - ( floor( ( MINIMUM_VALID_NUMBER - 1 - ATTRIBUTE ) / ( abs( MINIMUM_VALID_NUMBER - 1 - ATTRIBUTE ) + 0.001 ) ) + 1 ) ) ]]
```

Формула ниже возвращает ATTRIBUTE, если это целое число, которое больше или равно MINIMUM\_VALID\_NUMBER, и будет равна 0 для всех остальных целых чисел.


```text
[[ ATTRIBUTE * ( 1 - ( floor( ( MINIMUM_VALID_NUMBER - 1 - ATTRIBUTE ) / ( abs( MINIMUM_VALID_NUMBER - 1 - ATTRIBUTE ) + 0.001 ) ) + 1 ) ) ]]
```

### Больше или равно

Приведенная ниже формула возвращает 1 для всех целых чисел MAXIMUM\_VALID\_NUMBER или меньше, и возвращает 0 для всех остальных целых чисел. Это полезно для ситуаций, когда при превышении определенного максимума нужно игнорировать это значение\ (например, игнорировать бонус Лов при плоскостопии, но сохранять штраф\).

```text
[[ ( floor( ( MAXIMUM_VALID_NUMBER - ATTRIBUTE ) / ( abs( MAXIMUM_VALID_NUMBER - ATTRIBUTE ) + 0.001 ) ) + 1 ) ]]
```

Формула ниже возвращает ATTRIBUTE, если это целое число, которое меньше или равно MAXIMUM\_VALID\_NUMBER, и будет равна 0 для всех остальных целых чисел.

```text
[[ ATTRIBUTE * ( floor( ( MAXIMUM_VALID_NUMBER - ATTRIBUTE ) / ( abs( MAXIMUM_VALID_NUMBER - ATTRIBUTE ) + 0.001 ) ) + 1 ) ]]
```

### Полный пример использования

Таким образом, чтобы игнорировать бонус Лов, но сохранить пенальти Лов, вы можете записать следующий шаблон по умолчанию в макрос действия токена, видимый всем игрокам:

```text
/w gm &{template:default} {{name=AC Roll Modifiers for @{selected|character_name} }} {{Flat-Footed=+[[ @{selected|acitembonus} + @{selected|shieldbonus} + @{selected|size} + @{selected|armorclassnaturalarmor} + @{selected|armorclassdeflectionmod} + @{selected|armorclassmiscmod} + @{selected|dexmod} * ( floor( ( (-1) - @{selected|dexmod} ) / ( abs( (-1) - @{selected|dexmod} ) + 0.001 ) ) + 1 ) ]] = [[ @{selected|acitembonus} + @{selected|shieldbonus} + @{selected|size} + @{selected|armorclassnaturalarmor} + @{selected|armorclassdeflectionmod} + @{selected|armorclassmiscmod} + @{selected|dexmod} * ( floor( ( (-1) - @{selected|dexmod} ) / ( abs( (-1) - @{selected|dexmod} ) + 0.001 ) ) + 1 ) +10 ]] (Subtract lost Dodge bonus)}}
```

### Булевые числа

Допустим, вы используете вариант бонуса к защите, в котором нематериальный доспех складывается с бонусом к защите. Вы не можете просто использовать атрибут @{selected\|acitembonus}, чтобы определить, применяется ли бонус к защите, но если у вас есть пользовательский атрибут для всех существ под названием "Носит ли физический доспех?", вы можете сделать его булевой 1 или 0 в зависимости от того, так это или нет.

```text
[[ @{selected|DefenseBonus}-(@{selected|DefenseBonus}*@{selected|Is Wearing Physical Armor?}) ]]
```

Конечно, формулу можно было бы упростить, если бы атрибутом было "Не носит физических доспехов".

```text
[[ @{selected|DefenseBonus}*@{selected|Is NOT Wearing Physical Armor?} ]]
```

Однако, глядя на список атрибутов персонажа, легче понять логику, согласно которой "1" подтверждает положительное, а не отрицательное.

